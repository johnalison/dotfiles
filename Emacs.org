#+title: Emacs Configuration
#+PROPERTY: header-args:emacs-lisp :tangle ~/dotfiles/init-new.el


* Package System Setup

#+begin_src emacs-lisp


  ;; MELPA
  (require 'package)

  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("org" . "https://orgmode.org/elpa/")
                           ("elpa" . "https://elpa.gnu.org/packages/")))


  (package-initialize)
  ;;(unless package-archive-contents
  ;;  (package-refresh-contents))

  ;;(require 'use-package)
  ;;'(setq use-package-always-ensure t)
  

#+end_src

* Basic UI Configuration

Simplify the UI

#+begin_src emacs-lisp

  ;; Simplify the UI
  (setq inhibit-startup-message t)

  (scroll-bar-mode -1)        ; Disable visible scrollbar
  (tool-bar-mode -1)          ; Disable the toolbar
  (tooltip-mode -1)           ; Disable tooltips
  (set-fringe-mode 10)        ; Give some breathing room
  (menu-bar-mode -1)          ; Disable the menu bar


  ;; Set up the visible bell
  (setq ring-bell-function 'ignore)


#+end_src

No Backup files

#+begin_src emacs-lisp
  (setq make-backup-files nil) ;turn off the backup files
#+end_src

Copy and paste

#+begin_src emacs-lisp

  (setq save-interprogram-paste-before-kill t)
  ;;(setq select-enable-clipboard t)
  (setq select-enable-clipboard nil)

  ;; Make cut and paste work with the macOS clipboard
  (defun yank-from-osx-clipboard ()
    "Insert the contents of the macOS clipboard at point."
    (interactive)
    (insert (shell-command-to-string "pbpaste")))

  (global-set-key (kbd "s-v") 'yank-from-osx-clipboard)

#+end_src

Copy the current region to the clipboard.  Bound to =C-c e=
#+begin_src emacs-lisp

  (defun copy-region-to-pbcopy ()
    "Copy the current region to the clipboard using pbcopy."
    (interactive)
    (if (use-region-p)
        (progn
          (shell-command-on-region (region-beginning) (region-end) "pbcopy")
          (deactivate-mark) ; Optionally deactivate the mark
          (message "Region copied to clipboard using pbcopy!"))
      (message "No active region!")))


  (global-set-key "\C-ce" 'copy-region-to-pbcopy)

#+end_src


* UI Configuration

** scolling

#+begin_src emacs-lisp

  (defalias 'scroll-ahead `scroll-up)
  (defalias 'scroll-behind `scroll-down)

  (defun scroll-n-lines-ahead (&optional n)
    "Scroll ahead N lines (1 by default)."
    (interactive "P")
    (scroll-ahead (prefix-numeric-value n)))

  (defun scroll-n-lines-behind (&optional n)
    "Scroll behind N lines (1 by default)."
    (interactive "P")
    (scroll-behind (prefix-numeric-value n)))


  (global-set-key "\C-q" 'scroll-n-lines-behind)
  (global-set-key "\C-x\C-q" 'quoted-insert)
  (global-set-key "\C-z" 'scroll-n-lines-ahead)


  (defun point-to-top ()
    "Put point on the top line of window"
    (interactive)
    (move-to-window-line 0))

  (defun point-to-bottom ()
    "Put point on the top line of window"
    (interactive)
    (move-to-window-line -1))

  (defun line-to-top ()
    "Move the current line to top of window."
    (interactive)
    (recenter 0))


  (global-set-key "\M-," 'point-to-top)
  (global-set-key "\M-." 'point-to-bottom)
  (global-set-key "\M-!" 'line-to-top)

#+end_src

Save hist

#+begin_src emacs-lisp

  (use-package savehist
    :init
    (savehist-mode))

#+end_src

* Key bindings

#+begin_src emacs-lisp

  (global-set-key "\C-h" 'delete-backward-char)
  (global-set-key (kbd "C-?") 'help-command)
  (global-set-key "\M-h" 'backward-kill-word)
  (global-set-key "\M-w" 'ispell-word)
  (global-set-key "\M-#" 'ispell-region)

  (global-set-key "\C-l" 'goto-line)
  (global-set-key "\M-n" 'forward-paragraph)
  (global-set-key "\M-p" 'backward-paragraph)

  (global-set-key (kbd "C-c r") 'revert-buffer-quick)
  (global-set-key "\M-?" 'help-command)
  (global-set-key (kbd "<backtab>") 'dabbrev-expand)

#+end_src


* Which key

[[https://github.com/justbur/emacs-which-key][which-key]]  is a useful UI panel that appears when you start pressing any key binding in Emacs to offer you all possible completions for the prefix. For example, if you press =C-c= (hold control and press the letter =c=), a panel will appear at the bottom of the frame displaying all of the bindings under that prefix and which command they run. This is very useful for learning the possible key bindings in the mode of your current buffer. The =which-key-idle-delay= sets how long until the pannel shows

#+begin_src emacs-lisp

  (use-package which-key
    :init (which-key-mode)
    :diminish which-key-mode
    :config
    (setq which-key-idle-delay 1))

#+end_src

* Counsel

Counsel is a customized set of commands to replace `find-file` with `counsel-find-file`, etc which provide useful commands for each of the default completion commands.

#+begin_src emacs-lisp

  (use-package counsel
    :bind (("M-X" . counsel-M-x)
           ("C-x B" . counsel-ibuffer)
           ;("C-x F" . counsel-find-file)
           :map minibuffer-local-map
           ("C-r" . 'counsel-minibuffer-history)))

#+end_src


* Helpful

[[https://github.com/Wilfred/helpful][Helpful]] adds a lot of very helpful information to Emacs’ describe- command buffers. For example, if you use describe-function, you will not only get the documentation about the function, you will also see the source code of the function and where it gets used in other places in the Emacs configuration. It is very useful for figuring out how things work in Emacs.

#+begin_src emacs-lisp

  (use-package helpful
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ([remap describe-function] . counsel-describe-function)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . counsel-describe-variable)
    ([remap describe-key] . helpful-key))


#+end_src


* Check Buffer before switching

#+begin_src emacs-lisp

; Check buffer exists before switching there
(defadvice switch-to-buffer (before existing-buffer
				    activate compile)
  "When interactive, swtich to existing buffers only,
   unless given a prefex argument."
  (interactive
   (list (read-buffer "Switch to buffer: "
		      (other-buffer)
		      (null current-prefix-arg)))))

  
#+end_src


* Text Editing 

Whitespace

#+begin_src emacs-lisp


  (defun replace-blank-lines-with-true-blanks ()
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^[ \t]+$" nil t)
        (replace-match "" nil nil))))

  (defun remove-trailing-whitespace ()
    (interactive)
    (when (derived-mode-p 'python-mode 'emacs-lisp-mode)
      (delete-trailing-whitespace)))

  (add-hook 'before-save-hook 'remove-trailing-whitespace)


#+end_src


* Copilot

https://github.com/copilot-emacs/copilot.el

#+begin_src emacs-lisp

  ;; Setting up copilot
  (add-to-list 'load-path "~/emacs/copilot.el")
  (require 'editorconfig)
  (require 'copilot)
  (add-hook 'prog-mode-hook 'copilot-mode)
  (define-key copilot-completion-map (kbd "<backtab>") 'copilot-accept-completion)
  (define-key copilot-completion-map (kbd "C-c C-f") 'copilot-accept-completion-by-word)
  (setq warning-suppress-types '((copilot)))

#+end_src



* GPTel


#+begin_src emacs-lisp


  ;; Setting up gptel
  (add-to-list 'load-path "~/emacs/gptel")
  (use-package gptel
    :ensure t
    :config
    ;; either hard‑code it (not recommended for shared configs):
    ;;(setq gptel-api-key "sk‑YOUR_SECRET_KEY_HERE")

    ;; or, read from your shell’s env var:
    (setq gptel-api-key (getenv "OPENAI_API_KEY")))

  (global-set-key (kbd "C-c RET") 'gptel-send)
  (global-set-key (kbd "C-c m") 'gptel-menu)


  (defun gptel-send-with-options (&optional arg)
    "Send query.  With prefix ARG open gptel's menu instead."
    (interactive "P")
    (if arg
        (call-interactively 'gptel-menu)
      (gptel--suffix-send (transient-args 'gptel-menu))))

  (global-set-key (kbd "C-c g") #'my-gptel-send-via-minibuffer-and-echo)

  (add-to-list 'load-path "~/emacs/gptel-quick/")

  ;; Optional defaults
  (setq gptel-use-tools t                 ; allow tool use by default
        gptel-confirm-tool-calls nil        ; ask before each invocation
        gptel-include-tool-results nil)     ; echo results back to the model


#+end_src



* Vertigo

The [[https://protesilaos.com/emacs/dotemacs#h:cff33514-d3ac-4c16-a889-ea39d7346dc5][Vertigo]] package applies a vertical layout to the minibuffer. It also pops up the minibuffer eagerly so we can see the available options without further interactions. This package is very fast and "just works", though it also is highly customisable in case we need to modify its behaviour.


#+begin_src emacs-lisp

  (use-package vertico
    :ensure t
    :custom
    (vertico-cycle t)
    :init
    (vertico-mode))

#+end_src



* Marginalia

The  [[https://protesilaos.com/emacs/dotemacs#h:bd3f7a1d-a53d-4d3e-860e-25c5b35d8e7e][Marginalia]] package provides helpful annotations next to  completion candidates in the minibuffer.  The information on display depends on the type of content.  If it is about files, it shows file permissions and the last modified date.  If it is a buffer, it shows the buffer's size, major mode, and the like.
 
#+begin_src emacs-lisp

  (use-package marginalia
    :after vertico
    :ensure t
    :custom
    (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
    :init
    (marginalia-mode))

#+end_src

* Rainbow Delimiters

[[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] is useful in programming modes because it colorizes nested parentheses and brackets according to their nesting depth. This makes it a lot easier to visually match parentheses in Emacs Lisp code without having to count them yourself.

#+begin_src emacs-lisp

  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))

#+end_src


* Emacs vs Emacs -nw config

#+begin_src emacs-lisp

  (unless (eq window-system nil)
    (use-package doom-themes
      :init (load-theme 'modus-operandi t)))

#+end_src


* Tramps 

#+begin_src emacs-lisp

  (setq remote-lpc-coffea4bees-path "/ssh:jda102@cmslpc-el9.fnal.gov:/uscms/home/jda102/nobackup/HH4b/Run3/coffea4bees/")

  ;; Example of using the variable
  (defun open-lpc-coffea4bees ()
    "Open the remote HH4b directory."
    (interactive)
    (find-file remote-lpc-coffea4bees-path))
    
#+end_src


; org roam

; Org Mode
(load "~/lab/emacs/johns-org.el")

;; GCal
(load "~/lab/emacs/gcal-setup.el")




;; The `orderless' package lets the minibuffer use an out-of-order
;; pattern matching algorithm.  It matches space-separated words or
;; regular expressions in any order.  In its simplest form, something
;; like "ins pac" matches `package-menu-mark-install' as well as
;; `package-install'.  This is a powerful tool because we no longer
;; need to remember exactly how something is named.
;;
;; Note that Emacs has lots of "completion styles" (pattern matching
;; algorithms), but let us keep things simple.
;;
;; Further reading: https://protesilaos.com/emacs/dotemacs#h:7cc77fd0-8f98-4fc0-80be-48a758fcb6e2
(use-package orderless
  :ensure t
  :config
  (setq completion-styles '(orderless basic)))


;; The `consult' package provides lots of commands that are enhanced
;; variants of basic, built-in functionality.  One of the headline
;; features of `consult' is its preview facility, where it shows in
;; another Emacs window the context of what is currently matched in
;; the minibuffer.  Here I define key bindings for some commands you
;; may find useful.  The mnemonic for their prefix is "alternative
;; search" (as opposed to the basic C-s or C-r keys).
;;
;; Further reading: https://protesilaos.com/emacs/dotemacs#h:22e97b4c-d88d-4deb-9ab3-f80631f9ff1d
(use-package consult
  :ensure t
  :bind (;; A recursive grep
         ("M-s g" . consult-grep)
         ;; Search for files names recursively
         ("M-s f" . consult-find)
         ;; Search through the outline (headings) of the file
         ("M-s M-o" . consult-outline)
         ;; Search the current buffer
         ("M-s M-l" . consult-line)
         ;; Switch to another buffer, or bookmarked file, or recently
         ;; opened file.
         ("M-s b" . consult-buffer)))

;;
;; Magit
;; The `magit' package is a powerful interface to Git.
(use-package magit
  :ensure t)





;; Dired
;; The `dired' package is the built-in file manager of Emacs.
(use-package dired
  :ensure nil              ;; dired is built-in
  :bind (:map dired-mode-map
              ("b" . dired-up-directory))
  :custom ((insert-directory-program "gls")
	   (dired-listing-switches "-agho --group-directories-first")
	   ;;(dired-dwim-target t)
	   ;;(dired-recursive-copies 'always)
	   ;;(dired-recursive-deletes 'top)
	   )
  )


(with-eval-after-load 'dired
  (require 'dired-x))

(use-package dired-open
  :config
  ;; Doesn't work as expected!
  (add-to-list 'dired-open-functions #'dired-open-xdg t)
  ;; -- OR! --
  (setq dired-open-extensions '(("key" . "open")
				("docx" . "open")
				("pdf" . "open"))))


(use-package dired-hide-dotfiles
  :hook (dired-mode . dired-hide-dotfiles-mode)
  :bind(:map dired-mode-map
	("H" . dired-hide-dotfiles-mode)
  ))
  ;;:config
  ;;(evil-collection-define-key 'normal 'dired-mode-map
  ;;  "H" 'dired-hide-dotfiles-mode))


(add-to-list 'load-path "/opt/homebrew/share/emacs/site-lisp/mu/mu4e") ;; adjust path if needed


(defun efs/capture-mail-follow-up (msg)
  "Capture a follow-up task from an email."
  (interactive)
  (call-interactively 'org-store-link)
  (org-capture nil "mf"))

(defun efs/capture-mail-read-later (msg)
  "Capture a readlater task from an email."
  (interactive)
  (call-interactively 'org-store-link)
  (org-capture nil "mr"))


(use-package mu4e
  :ensure nil
  ;:load-path "/opt/homebrew/share/emacs/site-lisp/mu/mu4e"
  :defer 20 ; Wait until 20 seconds after startup
  :bind(:map mu4e-search-minor-mode-map
	     ("M-<right>" . right-word)
	     ("M-<left>" .  left-word)
	     )
  :bind(:map mu4e-compose-mode-map
  	     ("M-n" .  forward-paragraph)
	     ("M-p" .  backward-paragraph)
	     )

  :config
  (require 'mu4e-org)
  ;; This is set to 't' to avoid mail syncing issues when using mbsync
  (setq mu4e-change-filenames-when-moving t)

  ;; Refresh mail using isync every 30 minutes
  (setq mu4e-update-interval (* 30 60))
  (setq mu4e-get-mail-command "mbsync -a")
  (setq mu4e-maildir "~/Mail")
  (setq mu4b-mu-binary "/opt/homebrew/bin/mu")
  (setq user-mail-address  "johnalison@cmu.edu")
  (setq mu4e-drafts-folder "/[Gmail]/Drafts")
  (setq mu4e-sent-folder   "/[Gmail]/Sent Mail")
  (setq mu4e-refile-folder "/[Gmail]/All Mail")
  (setq mu4e-trash-folder  "/[Gmail]/Trash")
  (setq mu4e-compose-format-flowed t)
  (setq mu4e-compose-signature nil)

  (setq mu4e-headers-show-threads nil)      ;; Main option to disable threading
  (setq mu4e-headers-include-related nil)   ;; Don't include related messages
  (setq mu4e-headers-skip-duplicates nil)   ;; Show all messages, even duplicates


  ;; Add custom actions for our capture templates
  (add-to-list 'mu4e-headers-actions
	       '("follow up" . efs/capture-mail-follow-up) t)
  (add-to-list 'mu4e-view-actions
	       '("follow up" . efs/capture-mail-follow-up) t)
  (add-to-list 'mu4e-headers-actions
	       '("read later" . efs/capture-mail-read-later) t)
  (add-to-list 'mu4e-view-actions
	       '("read later" . efs/capture-mail-read-later) t)


  (setq mu4e-bookmarks
	'(("flag:unread AND NOT flag:trashed" "Unread messages"      ?i)
	  ("flag:flagged AND NOT flag:trashed"                     "Flagged"             ?f)
	  ("maildir:\"/Inbox\" and date:today..now AND NOT flag:trashed"                  "Today's messages"     ?t)
	  ("maildir:\"/Inbox\" and date:7d..now AND NOT flag:trashed"                  "This Weeks's messages"     ?w)
	  ("maildir:\"/Inbox\" and date:30d..now AND NOT flag:trashed"                  "This Months's messages"     ?m)
	  ;("date:7d..now AND NOT flag:trashed"                     "Last 7 days"          ?w)
	  ;("mime:image/*"                     "Messages with images" ?p))
	))


  (setq mu4e-maildir-shortcuts
      '(("/Inbox"             . ?i)
        ("/[Gmail]/Sent Mail" . ?s)
        ("/[Gmail]/Trash"     . ?t)
        ;;("/[Gmail]/Important" . ?m)
        ("/[Gmail]/Drafts"    . ?d)
        ("/[Gmail]/All Mail"  . ?a)))

  (setq
   message-send-mail-function 'smtpmail-send-it
   smtpmail-smtp-user "johnda102@gmail.com"
   smtpmail-smtp-server "smtp.gmail.com"
   smtpmail-smtp-service 587
   smtpmail-stream-type 'starttls
   smtpmail-auth-credentials "~/.authinfo.gpg")


  (mu4e t)
  )

  
* Org Mode

** Auto-tangle configuration files

This snippet adds a hook to org-mode buffers so that efs/org-babel-tangle-config gets executed each time such a buffer gets saved. This function checks to see if the file being saved is the Emacs.org file you’re looking at right now, and if so, automatically exports the configuration here to the associated output files.

#+begin_src emacs-lisp :tangle ~/dotfiles/init-org.el

  ;; Automatically tangle our Emacs.org config file when we save it
  (defun efs/org-babel-tangle-config ()
    (when (string-equal (buffer-file-name)
                        (expand-file-name "~/dotfiles/Emacs.org"))
      ;; Dynamic scoping to the rescue
      (let ((org-confirm-babel-evaluate nil))
        (org-babel-tangle))))

  (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'efs/org-babel-tangle-config)))

#+end_src




